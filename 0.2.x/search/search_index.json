{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About Polymer It's a library for creating server side content, that work for player's without mods or (required) resource packs! You can create blocks, items and entities, that not only will work fully on server side (and singleplayer), but also are represented on server the same as normal (vanilla/modded) ones (unlike bukkit/spigot ones, that are stored as vanilla block). This library also should work correctly with other, non-polymer mods and PolyMC! Adding as dependency: Add it to your dependencies like this: repositories { maven { url 'https://maven.nucleoid.xyz' } } dependencies { modImplementation include(\"eu.pb4:polymer:[TAG]\") } For [TAG] /polymer version I recommend you checking this maven . Latest version: Before starting There are few things you need to keep in mind while using Polymer. All your code that interacts with Polymer should: Be thread safe - code can run on main server thread, player's connection thread or client side rendering thread. Make sure to check every time you cast if it's really instance of it. Sometimes World won't be ServerWorld . Never implement Polymer interfaces on Vanilla Items/Blocks with mixins, it will end up really, really badly. Never add new BlockStates to non-polymer blocks, as it will cause desyncs (see previous point)! Please don't even try using registry replacement, it will break many other mods. Getting started Items Blocks Entities Resource Packs Other custom features (Optional) Client Side features Extensions Polymer Textured Blocks Other useful tools/projects compatible with Polymer Server Translation API","title":"About Polymer"},{"location":"#about-polymer","text":"It's a library for creating server side content, that work for player's without mods or (required) resource packs! You can create blocks, items and entities, that not only will work fully on server side (and singleplayer), but also are represented on server the same as normal (vanilla/modded) ones (unlike bukkit/spigot ones, that are stored as vanilla block). This library also should work correctly with other, non-polymer mods and PolyMC!","title":"About Polymer"},{"location":"#adding-as-dependency","text":"Add it to your dependencies like this: repositories { maven { url 'https://maven.nucleoid.xyz' } } dependencies { modImplementation include(\"eu.pb4:polymer:[TAG]\") } For [TAG] /polymer version I recommend you checking this maven . Latest version:","title":"Adding as dependency:"},{"location":"#before-starting","text":"There are few things you need to keep in mind while using Polymer. All your code that interacts with Polymer should: Be thread safe - code can run on main server thread, player's connection thread or client side rendering thread. Make sure to check every time you cast if it's really instance of it. Sometimes World won't be ServerWorld . Never implement Polymer interfaces on Vanilla Items/Blocks with mixins, it will end up really, really badly. Never add new BlockStates to non-polymer blocks, as it will cause desyncs (see previous point)! Please don't even try using registry replacement, it will break many other mods.","title":"Before starting"},{"location":"#getting-started","text":"Items Blocks Entities Resource Packs Other custom features (Optional) Client Side features","title":"Getting started"},{"location":"#extensions","text":"Polymer Textured Blocks Other useful tools/projects compatible with Polymer Server Translation API","title":"Extensions"},{"location":"ext/polymer-blocks/","text":"Polymer Textured Blocks This is additional module/extension of polymer, adding support for textured blocks. It requires server resource pack to be active work correctly. Adding to dependencies repositories { maven { url 'https://maven.nucleoid.xyz' } // You should have it } dependencies { modImplementation include(\"eu.pb4:polymer-blocks:[TAG]\") } For [TAG] /polymer-blocks version I recommend you checking this maven . Latest version: Creating a block. Creating a block is mostly the same as with regular polymer ones. Only difference is implementation of PolymerTexturedBlock interface, which acts as a marker. Supported block shapes/types Polymer Blocks supports few types of models/shapes. However, possible amount of blocks is limited, because we can't really add fully custom blocks on client yet. Every block type has its own functionality and behaviour: FULL_BLOCK - Noteblocks, have full collision and don't allow transparency, (limit: 799) TRANSPARENT_BLOCK - Mostly leaves, allow \"cutout\" textures, (limit: 104) FARMLAND_BLOCK - Farmland blocks, (limit: 5!) VINES_BLOCK - All centered vine blocks, Cave Vines, Twisted Vines and Weeping Vines, (limit: 100) PLANT_BLOCK - Small plant blocks, sugarcane and saplings, (limit: 21) KELP_BLOCK - Just kelp, (limit: 25) CACTUS_BLOCK - Just cactus, (limit: 15!) They all are accessible from BlockModelType enum. Defining a global model First thing you do, is creating a model definition. You should do that by calling one of PolymerBlockModel.of(...) methods. It takes the same argument as vanilla definition in assets/(namespace)/blockstate/(block).json file. Then you need to request a model. It's as simple as calling PolymerBlockResourceUtils.requestBlock(BlockModelType type, PolymerBlockModel... model) with one or more models. It returns a blockstate, that you need to use in your PolymerTexturedBlock as result of getPolymerBlockState(...) . If it runs out of free BlockStates to use, it will return null instead. You can also check amount of free blocks with PolymerBlockResourceUtils.getBlocksLeft(BlockModelType type) . If you've done everything correctly, it should now display as your model. Otherwise, you either skipped some step or didn't apply server resource pack. Remember that you still need to register your assets with PolymerRPUtils.addAssetSource(String modId) method. Just keep in mind Some block model types have very small amount of free BlockStates. For that reason, while making public registering blocks globally, please allow for disabling of them and handle running out of them for best compatibility and mod support!","title":"Polymer Textured Blocks"},{"location":"ext/polymer-blocks/#polymer-textured-blocks","text":"This is additional module/extension of polymer, adding support for textured blocks. It requires server resource pack to be active work correctly.","title":"Polymer Textured Blocks"},{"location":"ext/polymer-blocks/#adding-to-dependencies","text":"repositories { maven { url 'https://maven.nucleoid.xyz' } // You should have it } dependencies { modImplementation include(\"eu.pb4:polymer-blocks:[TAG]\") } For [TAG] /polymer-blocks version I recommend you checking this maven . Latest version:","title":"Adding to dependencies"},{"location":"ext/polymer-blocks/#creating-a-block","text":"Creating a block is mostly the same as with regular polymer ones. Only difference is implementation of PolymerTexturedBlock interface, which acts as a marker.","title":"Creating a block."},{"location":"ext/polymer-blocks/#supported-block-shapestypes","text":"Polymer Blocks supports few types of models/shapes. However, possible amount of blocks is limited, because we can't really add fully custom blocks on client yet. Every block type has its own functionality and behaviour: FULL_BLOCK - Noteblocks, have full collision and don't allow transparency, (limit: 799) TRANSPARENT_BLOCK - Mostly leaves, allow \"cutout\" textures, (limit: 104) FARMLAND_BLOCK - Farmland blocks, (limit: 5!) VINES_BLOCK - All centered vine blocks, Cave Vines, Twisted Vines and Weeping Vines, (limit: 100) PLANT_BLOCK - Small plant blocks, sugarcane and saplings, (limit: 21) KELP_BLOCK - Just kelp, (limit: 25) CACTUS_BLOCK - Just cactus, (limit: 15!) They all are accessible from BlockModelType enum.","title":"Supported block shapes/types"},{"location":"ext/polymer-blocks/#defining-a-global-model","text":"First thing you do, is creating a model definition. You should do that by calling one of PolymerBlockModel.of(...) methods. It takes the same argument as vanilla definition in assets/(namespace)/blockstate/(block).json file. Then you need to request a model. It's as simple as calling PolymerBlockResourceUtils.requestBlock(BlockModelType type, PolymerBlockModel... model) with one or more models. It returns a blockstate, that you need to use in your PolymerTexturedBlock as result of getPolymerBlockState(...) . If it runs out of free BlockStates to use, it will return null instead. You can also check amount of free blocks with PolymerBlockResourceUtils.getBlocksLeft(BlockModelType type) . If you've done everything correctly, it should now display as your model. Otherwise, you either skipped some step or didn't apply server resource pack. Remember that you still need to register your assets with PolymerRPUtils.addAssetSource(String modId) method.","title":"Defining a global model"},{"location":"ext/polymer-blocks/#just-keep-in-mind","text":"Some block model types have very small amount of free BlockStates. For that reason, while making public registering blocks globally, please allow for disabling of them and handle running out of them for best compatibility and mod support!","title":"Just keep in mind"},{"location":"other/server-translation-api/","text":"Server Translation API It's a library for handling translations server side. It supports per player language, by using one provided by client on join/language change. Adding as dependency: Add it to your dependencies like this: repositories { maven { url 'https://maven.nucleoid.xyz' } } dependencies { modImplementation include(\"fr.catcore:server-translations-api:[TAG]\") } For [TAG] /translations api version I recommend you checking this maven . Usage To use i, you just need to use vanilla TranslationText with key specified by you in your code. Then you just need to create data/modid/lang folder in your mod resources. Then you can create there en_us.json for default translation and other language files for other. Example valid language file looks like this: { \"block.honeytech.pipe\": \"Pipe\", \"block.honeytech.item_extractor\": \"Item Extractor\", \"block.honeytech.trashcan\": \"Trash Can\", \"block.honeytech.cable\": \"Cable\", \"item.honeytech.diamond_dust\": \"Diamond Dust\", \"item.honeytech.raw_aluminium\": \"Raw Aluminium Ore\", \"item.honeytech.aluminium_ingot\": \"Aluminium Ingot\", \"item.honeytech.copper_wire\": \"Copper Wire\", \"item.honeytech.motor\": \"Motor\", \"gui.honeytech.show_recipes\": \"Show Recipes\" }","title":"Server Translation API"},{"location":"other/server-translation-api/#server-translation-api","text":"It's a library for handling translations server side. It supports per player language, by using one provided by client on join/language change.","title":"Server Translation API"},{"location":"other/server-translation-api/#adding-as-dependency","text":"Add it to your dependencies like this: repositories { maven { url 'https://maven.nucleoid.xyz' } } dependencies { modImplementation include(\"fr.catcore:server-translations-api:[TAG]\") } For [TAG] /translations api version I recommend you checking this maven .","title":"Adding as dependency:"},{"location":"other/server-translation-api/#usage","text":"To use i, you just need to use vanilla TranslationText with key specified by you in your code. Then you just need to create data/modid/lang folder in your mod resources. Then you can create there en_us.json for default translation and other language files for other. Example valid language file looks like this: { \"block.honeytech.pipe\": \"Pipe\", \"block.honeytech.item_extractor\": \"Item Extractor\", \"block.honeytech.trashcan\": \"Trash Can\", \"block.honeytech.cable\": \"Cable\", \"item.honeytech.diamond_dust\": \"Diamond Dust\", \"item.honeytech.raw_aluminium\": \"Raw Aluminium Ore\", \"item.honeytech.aluminium_ingot\": \"Aluminium Ingot\", \"item.honeytech.copper_wire\": \"Copper Wire\", \"item.honeytech.motor\": \"Motor\", \"gui.honeytech.show_recipes\": \"Show Recipes\" }","title":"Usage"},{"location":"polymer/blocks/","text":"Blocks Note These docs will only take care about polymer-related part of creation of blocks. You might want to see official Fabric Wiki for more in depth look into how to create blocks. You can skip some client side specific things, as it won't take effect server side (for example models and textures). Creation of blocks Creation of blocks, similarly to items, is mostly the same as vanilla. Only real difference is that your blocks need to implement Polymer's PolymerBlock interface. It exposes few defaulted methods for manipulation of client side visuals. Default implementation For most basic uses, there are default implementation of PolymerBlock : PolymerHeadBlock - It's an interface (!), that has basic implementation of player head based blocks, you still need to apply it to your Block class, SimplePolymerBlock - Same as vanilla Block . Selecting base polymer block type. To change base block, you need to override Block getPolymerBlock(BlockState) method. You can also override Block getPolymerBlock(ServerPlayerEntity, BlockState) to replace blocks per player, however keep in mind they should ideally have same collisions. Both of these methods can't return null. They can also point to other PolymerBlock instances, but keep in mind to make validation if it's configurable by user! Example use: Making block look like a diamond @Override public Block getPolymerBlock(BlockState state) { return Blocks.BARRIER; } public Block getPolymerBlock(ServerPlayerEntity player, BlockState state) { return Something.isRedTeam(player) ? Blocks.RED_WOOL : Blocks.BLUE_WOOL; } Changing client-side and collision BlockStates If you want to change what BlockState will be used for server side collision and client side you need to override BlockState getPolymerBlockState(BlockState state) method. You can also override BlockState getPolymerBlockState(ServerPlayerEntity player, BlockState state) for player context, similar to getPolymerBlock . You can return other BlockState of PolymerBlock, but keep in mind you can only nest them up to 32! Example use: Changing BlockState to furnace with the same facing, but inverted \"lit\" BlockState property @Override public BlockState getPolymerBlockState(BlockState state) { return Blocks.FURNACE.getDefaultState() .with(AbstractFurnaceBlock.FACING, state.get(AbstractFurnaceBlock.FACING)) .with(AbstractFurnaceBlock.LIT, !state.get(AbstractFurnaceBlock.LIT)); } Sending additional data (signs/heads or even custom) In case if you want to send additional (to more customize look on client for signs/heads or additional data for companion mod), you need to override onPolymerBlockSend(ServerPlayerEntity player, BlockPos.Mutable pos, BlockState blockState) . Technically you can do anything there, but ideally it should be only used for packets. Example use: Sending data required to render player head with skin @Override public void onPolymerBlockSend(ServerPlayerEntity player, BlockPos.Mutable pos, BlockState blockState) { player.networkHandler.sendPacket(this.getPolymerHeadPacket(blockState, pos.toImmutable())); } Using PolymerHeadBlock PolymerHeadBlock is an interface extending PolymerBlock with methods prepared for usage of player heads as a block. To modify texture, you just need to override String getPolymerSkinValue(BlockState state) which should return texture value. To generate it you can use websites like https://mineskin.org/. Additionally, you can override BlockState getPolymerBlockState(BlockState state) to change rotation of Player Head Block. Example use: Setting skin value for PolymerHeadBlock @Override public String getPolymerSkinValue(BlockState state) { return \"ewogICJ0aW1lc3RhbXAiIDogMTYxNzk3NjcxOTAzNSwKICAicHJvZmlsZUlkIiA6ICJlZDUzZGQ4MTRmOWQ0YTNjYjRlYjY1MWRjYmE3N2U2NiIsCiAgInByb2ZpbGVOYW1lIiA6ICI0MTQxNDE0MWgiLAogICJzaWduYXR1cmVSZXF1aXJlZCIgOiB0cnVlLAogICJ0ZXh0dXJlcyIgOiB7CiAgICAiU0tJTiIgOiB7CiAgICAgICJ1cmwiIDogImh0dHA6Ly90ZXh0dXJlcy5taW5lY3JhZnQubmV0L3RleHR1cmUvNTczNTE0YTIzMjQ1ZjE1ZGJhZDVmYjRlNjIyMTYzMDIwODY0Y2NlNGMxNWQ1NmRlM2FkYjkwZmE1YTcxMzdmZCIKICAgIH0KICB9Cn0\"; } Textured, non-player-head blocks See Polymer Textured Blocks extension for more informations Using BlockEntities The only thing you need to do to remove BlockEntity from being sent to client is registering its BlockEntityType with PolymerBlockUtils.registerBlockEntity(BlockEntityType types) . Getting Polymer Blocks client representation If you want to get client-friendly representation of block, you need to call PolymerBlockUtils.getBlockStateSafely(PolymerBlock block, BlockState blockState) method. It should return block safe to use (or air in case of failure). Limitations While it's supported, please limit creation of PolymerBlock light sources. Because of how Minecraft handles light updates on server/client, these can be little laggy (as it needs to be sent updates every time light changes) and not perfect, as client is emulating light by itself. Similarly, client recalculates some BlockStates, which can cause some desyncs.","title":"Blocks"},{"location":"polymer/blocks/#blocks","text":"Note These docs will only take care about polymer-related part of creation of blocks. You might want to see official Fabric Wiki for more in depth look into how to create blocks. You can skip some client side specific things, as it won't take effect server side (for example models and textures).","title":"Blocks"},{"location":"polymer/blocks/#creation-of-blocks","text":"Creation of blocks, similarly to items, is mostly the same as vanilla. Only real difference is that your blocks need to implement Polymer's PolymerBlock interface. It exposes few defaulted methods for manipulation of client side visuals.","title":"Creation of blocks"},{"location":"polymer/blocks/#default-implementation","text":"For most basic uses, there are default implementation of PolymerBlock : PolymerHeadBlock - It's an interface (!), that has basic implementation of player head based blocks, you still need to apply it to your Block class, SimplePolymerBlock - Same as vanilla Block .","title":"Default implementation"},{"location":"polymer/blocks/#selecting-base-polymer-block-type","text":"To change base block, you need to override Block getPolymerBlock(BlockState) method. You can also override Block getPolymerBlock(ServerPlayerEntity, BlockState) to replace blocks per player, however keep in mind they should ideally have same collisions. Both of these methods can't return null. They can also point to other PolymerBlock instances, but keep in mind to make validation if it's configurable by user! Example use: Making block look like a diamond @Override public Block getPolymerBlock(BlockState state) { return Blocks.BARRIER; } public Block getPolymerBlock(ServerPlayerEntity player, BlockState state) { return Something.isRedTeam(player) ? Blocks.RED_WOOL : Blocks.BLUE_WOOL; }","title":"Selecting base polymer block type."},{"location":"polymer/blocks/#changing-client-side-and-collision-blockstates","text":"If you want to change what BlockState will be used for server side collision and client side you need to override BlockState getPolymerBlockState(BlockState state) method. You can also override BlockState getPolymerBlockState(ServerPlayerEntity player, BlockState state) for player context, similar to getPolymerBlock . You can return other BlockState of PolymerBlock, but keep in mind you can only nest them up to 32! Example use: Changing BlockState to furnace with the same facing, but inverted \"lit\" BlockState property @Override public BlockState getPolymerBlockState(BlockState state) { return Blocks.FURNACE.getDefaultState() .with(AbstractFurnaceBlock.FACING, state.get(AbstractFurnaceBlock.FACING)) .with(AbstractFurnaceBlock.LIT, !state.get(AbstractFurnaceBlock.LIT)); }","title":"Changing client-side and collision BlockStates"},{"location":"polymer/blocks/#sending-additional-data-signsheads-or-even-custom","text":"In case if you want to send additional (to more customize look on client for signs/heads or additional data for companion mod), you need to override onPolymerBlockSend(ServerPlayerEntity player, BlockPos.Mutable pos, BlockState blockState) . Technically you can do anything there, but ideally it should be only used for packets. Example use: Sending data required to render player head with skin @Override public void onPolymerBlockSend(ServerPlayerEntity player, BlockPos.Mutable pos, BlockState blockState) { player.networkHandler.sendPacket(this.getPolymerHeadPacket(blockState, pos.toImmutable())); }","title":"Sending additional data (signs/heads or even custom)"},{"location":"polymer/blocks/#using-polymerheadblock","text":"PolymerHeadBlock is an interface extending PolymerBlock with methods prepared for usage of player heads as a block. To modify texture, you just need to override String getPolymerSkinValue(BlockState state) which should return texture value. To generate it you can use websites like https://mineskin.org/. Additionally, you can override BlockState getPolymerBlockState(BlockState state) to change rotation of Player Head Block. Example use: Setting skin value for PolymerHeadBlock @Override public String getPolymerSkinValue(BlockState state) { return \"ewogICJ0aW1lc3RhbXAiIDogMTYxNzk3NjcxOTAzNSwKICAicHJvZmlsZUlkIiA6ICJlZDUzZGQ4MTRmOWQ0YTNjYjRlYjY1MWRjYmE3N2U2NiIsCiAgInByb2ZpbGVOYW1lIiA6ICI0MTQxNDE0MWgiLAogICJzaWduYXR1cmVSZXF1aXJlZCIgOiB0cnVlLAogICJ0ZXh0dXJlcyIgOiB7CiAgICAiU0tJTiIgOiB7CiAgICAgICJ1cmwiIDogImh0dHA6Ly90ZXh0dXJlcy5taW5lY3JhZnQubmV0L3RleHR1cmUvNTczNTE0YTIzMjQ1ZjE1ZGJhZDVmYjRlNjIyMTYzMDIwODY0Y2NlNGMxNWQ1NmRlM2FkYjkwZmE1YTcxMzdmZCIKICAgIH0KICB9Cn0\"; }","title":"Using PolymerHeadBlock"},{"location":"polymer/blocks/#textured-non-player-head-blocks","text":"See Polymer Textured Blocks extension for more informations","title":"Textured, non-player-head blocks"},{"location":"polymer/blocks/#using-blockentities","text":"The only thing you need to do to remove BlockEntity from being sent to client is registering its BlockEntityType with PolymerBlockUtils.registerBlockEntity(BlockEntityType types) .","title":"Using BlockEntities"},{"location":"polymer/blocks/#getting-polymer-blocks-client-representation","text":"If you want to get client-friendly representation of block, you need to call PolymerBlockUtils.getBlockStateSafely(PolymerBlock block, BlockState blockState) method. It should return block safe to use (or air in case of failure).","title":"Getting Polymer Blocks client representation"},{"location":"polymer/blocks/#limitations","text":"While it's supported, please limit creation of PolymerBlock light sources. Because of how Minecraft handles light updates on server/client, these can be little laggy (as it needs to be sent updates every time light changes) and not perfect, as client is emulating light by itself. Similarly, client recalculates some BlockStates, which can cause some desyncs.","title":"Limitations"},{"location":"polymer/client-side/","text":"Client side features While Polymer by itself is mainly server side api, it includes some client side functionality for mods to use. It allows you for example to display vanilla friendly item for normal clients and custom models if it's present on server. Keeping modded item/block on compatible client. To keep client side model for loading, you need to implement PolymerKeepModel interface on your modded object. To enable it's decoding, just add PolymerClientDecoded interface for it. After that, you just need to return server side items/block in corresponding player-aware getPolymerX methods. To \"sync\" presence/version of your mod you can use Polymer's handshake feature. You can do that by registering server packet like this, PolymerPacketUtils.registerServerPacket(PACKET_ID, 0, 1...); Where PACKET_ID is just instance of your Identifier, and numbers after it representing supported protocol versions (can be single or multiple). After that you can just validate if player supports it with this check it like this SomeObject getPolymerX(SomeObject serverObject, ServerPlayerEntity player) { if (PolymerPacketUtils.getSupportedVersion(player.networkHandler, PACKET_ID) > 0) { // Client state for modded return serverObject; } else { // Client state for vanilla return VanillaObjects.SOMETHING; }} This section is incomplete... I hope in code comments will guide you well...","title":"Client side features"},{"location":"polymer/client-side/#client-side-features","text":"While Polymer by itself is mainly server side api, it includes some client side functionality for mods to use. It allows you for example to display vanilla friendly item for normal clients and custom models if it's present on server.","title":"Client side features"},{"location":"polymer/client-side/#keeping-modded-itemblock-on-compatible-client","text":"To keep client side model for loading, you need to implement PolymerKeepModel interface on your modded object. To enable it's decoding, just add PolymerClientDecoded interface for it. After that, you just need to return server side items/block in corresponding player-aware getPolymerX methods. To \"sync\" presence/version of your mod you can use Polymer's handshake feature. You can do that by registering server packet like this, PolymerPacketUtils.registerServerPacket(PACKET_ID, 0, 1...); Where PACKET_ID is just instance of your Identifier, and numbers after it representing supported protocol versions (can be single or multiple). After that you can just validate if player supports it with this check it like this SomeObject getPolymerX(SomeObject serverObject, ServerPlayerEntity player) { if (PolymerPacketUtils.getSupportedVersion(player.networkHandler, PACKET_ID) > 0) { // Client state for modded return serverObject; } else { // Client state for vanilla return VanillaObjects.SOMETHING; }}","title":"Keeping modded item/block on compatible client."},{"location":"polymer/client-side/#this-section-is-incomplete-i-hope-in-code-comments-will-guide-you-well","text":"","title":"This section is incomplete... I hope in code comments will guide you well..."},{"location":"polymer/entities/","text":"Entities Note These docs will only take care about polymer-related part of creation of entities. You might want to see official Fabric Wiki for more in depth look into how to create entities. You can skip most client side specific things, as it won't take effect server side (for example rendering/models) Creation of entities Creation of entities is mostly the same as vanilla. You just need to implement PolymerEntity interface on your entity's class. It exposes few defaulted methods for manipulation of client side visuals. You also need to register your entity type as virtual, by using PolymerEntityUtils.registerType(EntityType... types) . Changing client side entity. To select visual entity type, you just need to override EntityType<?> getPolymerEntityType() This method can't return null or another EntityType that points to other virtual entity, as it won't work. Example use: Displaying entity as zombie @Override public EntityType<?> getPolymerEntityType() { return EntityType.ZOMBIE; } Modifying held items You most likely want to modify items held by entity, to indicate its type. To do it you need to override List<Pair<EquipmentSlot, ItemStack>> getPolymerVisibleEquipment(Map<EquipmentSlot, ItemStack> map) . Example use: Displaying real items with helmet replacement. @Override public List<Pair<EquipmentSlot, ItemStack>> getPolymerVisibleEquipment(Map<EquipmentSlot, ItemStack> map) { List<Pair<EquipmentSlot, ItemStack>> list = new ArrayList<>(map.size()); for (Map.Entry<EquipmentSlot, ItemStack> entry : map.entrySet()) { if (entry.getKey() == EquipmentSlot.HEAD) { continue; } else { list.add(Pair.of(entry.getKey(), entry.getValue())); } } list.add(new Pair<>(EquipmentSlot.HEAD, new ItemStack(Items.WITHER_SKELETON_SKULL))); return list; } Modifying client-side data trackers For more control over entity, you can modify DataTracker values send to client directly. To do it, you need to override void modifyTrackedData(List<DataTracker.Entry<?>> data) method. data already doesn't contain any invalid data. You should also be safe around it, as sending DataTracker.Entry's, that don't exist on client-side entity representation will cause issues and errors! To get TrackedData , which is needed to create Entries, you will need to make accessors to get private static values from entity classes. Example use: Adding villager data to change how villager looks @Override public void modifyTrackedData(List<DataTracker.Entry<?>> data) { data.add(new DataTracker.Entry<>(VillagerEntityAccessor.getVillagerData(), new VillagerData(VillagerType.JUNGLE, VillagerProfession.FARMER, 3);)); }","title":"Entities"},{"location":"polymer/entities/#entities","text":"Note These docs will only take care about polymer-related part of creation of entities. You might want to see official Fabric Wiki for more in depth look into how to create entities. You can skip most client side specific things, as it won't take effect server side (for example rendering/models)","title":"Entities"},{"location":"polymer/entities/#creation-of-entities","text":"Creation of entities is mostly the same as vanilla. You just need to implement PolymerEntity interface on your entity's class. It exposes few defaulted methods for manipulation of client side visuals. You also need to register your entity type as virtual, by using PolymerEntityUtils.registerType(EntityType... types) .","title":"Creation of entities"},{"location":"polymer/entities/#changing-client-side-entity","text":"To select visual entity type, you just need to override EntityType<?> getPolymerEntityType() This method can't return null or another EntityType that points to other virtual entity, as it won't work. Example use: Displaying entity as zombie @Override public EntityType<?> getPolymerEntityType() { return EntityType.ZOMBIE; }","title":"Changing client side entity."},{"location":"polymer/entities/#modifying-held-items","text":"You most likely want to modify items held by entity, to indicate its type. To do it you need to override List<Pair<EquipmentSlot, ItemStack>> getPolymerVisibleEquipment(Map<EquipmentSlot, ItemStack> map) . Example use: Displaying real items with helmet replacement. @Override public List<Pair<EquipmentSlot, ItemStack>> getPolymerVisibleEquipment(Map<EquipmentSlot, ItemStack> map) { List<Pair<EquipmentSlot, ItemStack>> list = new ArrayList<>(map.size()); for (Map.Entry<EquipmentSlot, ItemStack> entry : map.entrySet()) { if (entry.getKey() == EquipmentSlot.HEAD) { continue; } else { list.add(Pair.of(entry.getKey(), entry.getValue())); } } list.add(new Pair<>(EquipmentSlot.HEAD, new ItemStack(Items.WITHER_SKELETON_SKULL))); return list; }","title":"Modifying held items"},{"location":"polymer/entities/#modifying-client-side-data-trackers","text":"For more control over entity, you can modify DataTracker values send to client directly. To do it, you need to override void modifyTrackedData(List<DataTracker.Entry<?>> data) method. data already doesn't contain any invalid data. You should also be safe around it, as sending DataTracker.Entry's, that don't exist on client-side entity representation will cause issues and errors! To get TrackedData , which is needed to create Entries, you will need to make accessors to get private static values from entity classes. Example use: Adding villager data to change how villager looks @Override public void modifyTrackedData(List<DataTracker.Entry<?>> data) { data.add(new DataTracker.Entry<>(VillagerEntityAccessor.getVillagerData(), new VillagerData(VillagerType.JUNGLE, VillagerProfession.FARMER, 3);)); }","title":"Modifying client-side data trackers"},{"location":"polymer/items/","text":"Items Note These docs will only take care about polymer-related part of creation of items. You might want to see official Fabric Wiki for more in depth look into how to create items. You can skip some client side specific things, as it won't take effect server side (excluding item groups, as they can be used by other mods) Creation of items Creation of items is mostly the same as vanilla. Only real difference is that your items need to implement Polymer's PolymerItem interface. It exposes few defaulted methods for manipulation of client side visuals. Default implementation For most basic uses, there are default implementation of PolymerItem : SimplePolymerItem - Same as vanilla Item , PolymerSpawnEggItem - Same as vanilla SpawnEggItem , PolymerBlockItem - Same as vanilla BlockItem , PolymerHeadBlockItem - Similar to VirtualBlockItem , but for Blocks implementing VirtualHeadBlock interface. Selecting visual item type. To select visual item type, you need to implement this method * Item getPolymerItem(ItemStack itemStack, @Nullable ServerPlayerEntity player) They can't return nulls. They can also point to other PolymerItem instance, but keep in mind to make validation if it's configurable by user! Example use: Changing client-side item to diamond @Override public Item getPolymerItem(ItemStack itemStack, @Nullable ServerPlayerEntity player) { return itemStack.getCount() > 32 ? Items.DIAMOND_BLOCK : Items.DIAMOND; } Manipulation of client side ItemStack Sometimes it's useful to manipulate entire ItemStack, as it allows achieving better effects. To do so, you need to override the ItemStack getPolymerItemStack(ItemStack itemStack, @Nullable ServerPlayerEntity player) method. However, keep in mind that making nbt incorrect might create some issues (for example breaking items in creative mode)! Ideally you should modify output of PolymerItem.super.getPolymerItemStack(itemStack, player) , PolymerItemUtils.createItemStack(itemStack, player) or PolymerItemUtils.createMinimalItemStack(itemStack, player) , as they contain all required NBT. Example use: Adding enchanting glint to item. @Override public ItemStack getPolymerItemStack(ItemStack itemStack, ServerPlayerEntity player) { ItemStack out = PolymerItemUtils.createItemStack(itemStack, player); out.addEnchantment(Enchantments.LURE, 0); return out; } Support of models/CustomModelData You can change custom model data of virtual model by simple overriding int getPolymerCustomModelData(ItemStack itemStack, @Nullable ServerPlayerEntity player) . You can return -1 to disable it, or any number above it to set value of it. Ideally you should return value created with polymer's resource pack utils , but nothing blocks you from using any other ones. Example usage: Changing client-side item CustomModelData to previously stored value. @Override public int getPolymerCustomModelData(ItemStack itemStack, @Nullable ServerPlayerEntity player) { // Instance of PolymerModelData, see info above return this.cmd.value(); } Item Groups support You can create server side Item Groups, which will be later synced with Polymer-compatible clients. They also allow you to create server side Creative categories, that are accessible via /polymer creative command. To create, it, you just need to call one of provided PolymerItemGroup.create(Identifier, Text, [Supplier<ItemStack>]) static method. Then you can use it like regular ItemGroup. Manipulation of non-polymer items Sometimes, you might want to manipulate other vanilla/modded items without implementing PolymerItem on them. You can do it by using few events from PolymerItemUtils . Forcing items to go through Polymer To force items to go through polymer's client side item creation, you need to register event handler for PolymerItemUtils.ITEM_CHECK event. You can register it by using PolymerItemUtils.ITEM_CHECK.register(ItemStack -> boolean) lambda. Example use: Making every item with string NBT tag of \"Test\" go through polymer PolymerItemUtils.ITEM_CHECK.register( (itemStack) -> { return itemStack.hasNbt() && itemStack.getNbt().contains(\"Test\", NbtElement.STRING_TYPE); } ); Modification of Client side item After getting vanilla (or for any VirtualItem by default) you can modify any client side item with PolymerItemUtils.ITEM_MODIFICATION_EVENT event. Just keep in mind doing it incorrectly can cause issues (mostly around creative mode, but also in case you modify original item). You change the client side item by either directly modifying virtual ItemStack or creating new one and returning it. Ideally you should also keep previous nbt, just so it can work nicely, You can register this event by using PolymerItemUtils.ITEM_MODIFICATION_EVENT.register(((ItemStack original, ItemStack client, ServerPlayerEntity player) -> ItemStack) lambda. Example use: Hiding enchantment glint for items with HideEnchantments: 1b nbt tag PolymerItemUtils.ITEM_MODIFICATION_EVENT.register( (original, virtual, player) -> { if (original.hasNbt() && original.getNbt().getBoolean(\"HideEnchantments\")) { virtual.getNbt().remove(\"Enchantments\"); } return virtual; } ); Replacing look/name of ItemStack with \"Test\" NBT tag PolymerItemUtils.ITEM_MODIFICATION_EVENT.register( (original, virtual, player) -> { if (original.hasNbt() && original.getNbt().contains(\"Test\", NbtElement.STRING_TYPE)) { ItemStack out = new ItemStack(Items.DIAMOND_SWORD, virtual.getCount()); out.setNbt(virtual.getNbt()); out.setCustomName(new LiteralText(\"TEST VALUE: \" + original.getNbt().getString(\"Test\")).formatted(Formatting.WHITE)); return out; } return virtual; } ); Making items mining calculated on server side You can also force item's mining speed to be calculated server side (which happens by default to every VirtualItem). Only thing you need to do is just listening to BlockHelper.SERVER_SIDE_MINING_CHECK event. Example use: PolymerBlockUtils.SERVER_SIDE_MINING_CHECK.register( (player, pos, blockState) -> { var itemStack = player.getMainHandStack(); return EnchantmentHelper.getLevel(MyEnchanments.SLOW_MINING, itemStack) > 0; } ); Enchantments The only thing to make your enchantment fully server side is implementation of PolymerObject interface. You also might want to manipulate some things from Polymer Block/Item events.","title":"Items"},{"location":"polymer/items/#items","text":"Note These docs will only take care about polymer-related part of creation of items. You might want to see official Fabric Wiki for more in depth look into how to create items. You can skip some client side specific things, as it won't take effect server side (excluding item groups, as they can be used by other mods)","title":"Items"},{"location":"polymer/items/#creation-of-items","text":"Creation of items is mostly the same as vanilla. Only real difference is that your items need to implement Polymer's PolymerItem interface. It exposes few defaulted methods for manipulation of client side visuals.","title":"Creation of items"},{"location":"polymer/items/#default-implementation","text":"For most basic uses, there are default implementation of PolymerItem : SimplePolymerItem - Same as vanilla Item , PolymerSpawnEggItem - Same as vanilla SpawnEggItem , PolymerBlockItem - Same as vanilla BlockItem , PolymerHeadBlockItem - Similar to VirtualBlockItem , but for Blocks implementing VirtualHeadBlock interface.","title":"Default implementation"},{"location":"polymer/items/#selecting-visual-item-type","text":"To select visual item type, you need to implement this method * Item getPolymerItem(ItemStack itemStack, @Nullable ServerPlayerEntity player) They can't return nulls. They can also point to other PolymerItem instance, but keep in mind to make validation if it's configurable by user! Example use: Changing client-side item to diamond @Override public Item getPolymerItem(ItemStack itemStack, @Nullable ServerPlayerEntity player) { return itemStack.getCount() > 32 ? Items.DIAMOND_BLOCK : Items.DIAMOND; }","title":"Selecting visual item type."},{"location":"polymer/items/#manipulation-of-client-side-itemstack","text":"Sometimes it's useful to manipulate entire ItemStack, as it allows achieving better effects. To do so, you need to override the ItemStack getPolymerItemStack(ItemStack itemStack, @Nullable ServerPlayerEntity player) method. However, keep in mind that making nbt incorrect might create some issues (for example breaking items in creative mode)! Ideally you should modify output of PolymerItem.super.getPolymerItemStack(itemStack, player) , PolymerItemUtils.createItemStack(itemStack, player) or PolymerItemUtils.createMinimalItemStack(itemStack, player) , as they contain all required NBT. Example use: Adding enchanting glint to item. @Override public ItemStack getPolymerItemStack(ItemStack itemStack, ServerPlayerEntity player) { ItemStack out = PolymerItemUtils.createItemStack(itemStack, player); out.addEnchantment(Enchantments.LURE, 0); return out; }","title":"Manipulation of client side ItemStack"},{"location":"polymer/items/#support-of-modelscustommodeldata","text":"You can change custom model data of virtual model by simple overriding int getPolymerCustomModelData(ItemStack itemStack, @Nullable ServerPlayerEntity player) . You can return -1 to disable it, or any number above it to set value of it. Ideally you should return value created with polymer's resource pack utils , but nothing blocks you from using any other ones. Example usage: Changing client-side item CustomModelData to previously stored value. @Override public int getPolymerCustomModelData(ItemStack itemStack, @Nullable ServerPlayerEntity player) { // Instance of PolymerModelData, see info above return this.cmd.value(); }","title":"Support of models/CustomModelData"},{"location":"polymer/items/#item-groups-support","text":"You can create server side Item Groups, which will be later synced with Polymer-compatible clients. They also allow you to create server side Creative categories, that are accessible via /polymer creative command. To create, it, you just need to call one of provided PolymerItemGroup.create(Identifier, Text, [Supplier<ItemStack>]) static method. Then you can use it like regular ItemGroup.","title":"Item Groups support"},{"location":"polymer/items/#manipulation-of-non-polymer-items","text":"Sometimes, you might want to manipulate other vanilla/modded items without implementing PolymerItem on them. You can do it by using few events from PolymerItemUtils .","title":"Manipulation of non-polymer items"},{"location":"polymer/items/#forcing-items-to-go-through-polymer","text":"To force items to go through polymer's client side item creation, you need to register event handler for PolymerItemUtils.ITEM_CHECK event. You can register it by using PolymerItemUtils.ITEM_CHECK.register(ItemStack -> boolean) lambda. Example use: Making every item with string NBT tag of \"Test\" go through polymer PolymerItemUtils.ITEM_CHECK.register( (itemStack) -> { return itemStack.hasNbt() && itemStack.getNbt().contains(\"Test\", NbtElement.STRING_TYPE); } );","title":"Forcing items to go through Polymer"},{"location":"polymer/items/#modification-of-client-side-item","text":"After getting vanilla (or for any VirtualItem by default) you can modify any client side item with PolymerItemUtils.ITEM_MODIFICATION_EVENT event. Just keep in mind doing it incorrectly can cause issues (mostly around creative mode, but also in case you modify original item). You change the client side item by either directly modifying virtual ItemStack or creating new one and returning it. Ideally you should also keep previous nbt, just so it can work nicely, You can register this event by using PolymerItemUtils.ITEM_MODIFICATION_EVENT.register(((ItemStack original, ItemStack client, ServerPlayerEntity player) -> ItemStack) lambda. Example use: Hiding enchantment glint for items with HideEnchantments: 1b nbt tag PolymerItemUtils.ITEM_MODIFICATION_EVENT.register( (original, virtual, player) -> { if (original.hasNbt() && original.getNbt().getBoolean(\"HideEnchantments\")) { virtual.getNbt().remove(\"Enchantments\"); } return virtual; } ); Replacing look/name of ItemStack with \"Test\" NBT tag PolymerItemUtils.ITEM_MODIFICATION_EVENT.register( (original, virtual, player) -> { if (original.hasNbt() && original.getNbt().contains(\"Test\", NbtElement.STRING_TYPE)) { ItemStack out = new ItemStack(Items.DIAMOND_SWORD, virtual.getCount()); out.setNbt(virtual.getNbt()); out.setCustomName(new LiteralText(\"TEST VALUE: \" + original.getNbt().getString(\"Test\")).formatted(Formatting.WHITE)); return out; } return virtual; } );","title":"Modification of Client side item"},{"location":"polymer/items/#making-items-mining-calculated-on-server-side","text":"You can also force item's mining speed to be calculated server side (which happens by default to every VirtualItem). Only thing you need to do is just listening to BlockHelper.SERVER_SIDE_MINING_CHECK event. Example use: PolymerBlockUtils.SERVER_SIDE_MINING_CHECK.register( (player, pos, blockState) -> { var itemStack = player.getMainHandStack(); return EnchantmentHelper.getLevel(MyEnchanments.SLOW_MINING, itemStack) > 0; } );","title":"Making items mining calculated on server side"},{"location":"polymer/items/#enchantments","text":"The only thing to make your enchantment fully server side is implementation of PolymerObject interface. You also might want to manipulate some things from Polymer Block/Item events.","title":"Enchantments"},{"location":"polymer/other/","text":"Other custom features SoundEvents Polymer has support for creating custom sound events, that can fallback to vanilla sounds for players without resource packs and resource pack ones if they are present. To use it, you just need to create new instance of PolymerSoundEvent . You can use it similarly to vanilla ones. Custom statistics To register custom, server side statistic you just need to call PolymerStat.registerStat(Identifier, StatFormatter) . Then you can use it just like vanilla ones. StatusEffects To create custom, server side status effects, you just need to implement PolymerStatusEffect on your custom StatusEffect class. You can also override StatusEffect getPolymerStatusEffect() to display it as vanilla one (otherwise they are hidden).","title":"Other custom features"},{"location":"polymer/other/#other-custom-features","text":"","title":"Other custom features"},{"location":"polymer/other/#soundevents","text":"Polymer has support for creating custom sound events, that can fallback to vanilla sounds for players without resource packs and resource pack ones if they are present. To use it, you just need to create new instance of PolymerSoundEvent . You can use it similarly to vanilla ones.","title":"SoundEvents"},{"location":"polymer/other/#custom-statistics","text":"To register custom, server side statistic you just need to call PolymerStat.registerStat(Identifier, StatFormatter) . Then you can use it just like vanilla ones.","title":"Custom statistics"},{"location":"polymer/other/#statuseffects","text":"To create custom, server side status effects, you just need to implement PolymerStatusEffect on your custom StatusEffect class. You can also override StatusEffect getPolymerStatusEffect() to display it as vanilla one (otherwise they are hidden).","title":"StatusEffects"},{"location":"polymer/resource-packs/","text":"Resource packs While Polymer wasn't originally designed around resource pack, it provides resource pack utilities to make it easier for mods to stay compatible with each other. Currently, it's limited only to item models, as Vanilla only allows these (as of 1.17.1 version). Registering assets This is quite simple. You just need to do things written below. Ideally it all should run at your mod's initialization. Adding mod assets to resource pack First step for adding assets to resource pack is marking mod as asset source. To do it you just need to call boolean PolymerRPUtils.addAssetSource(String modid) , which returns true if modid is valid. This should be called ideally in your mod initializer. Additionally, you can add assets manually by calling PolymerRPBuilder.addData(String path, byte[] data) . You can get instance of it by listening to PolymerRPUtils.RESOURCE_PACK_CREATION_EVENT . Just keep in minds that new one will be created every time resource pack is generated. Requesting model for item After that you can register your models by calling PolymerModelData PolymerRPUtils.requestModel(Item vanillaItem, Identifier modelPath) . It returns PolymerModelData with contains all information you need for applying custom model data to your items. You need to keep in mind, that modelPath needs to contain main directory (in similar way to vanilla models). While model is created, all it's overrides are copied and applied, so you don't need to request them manually (useful for bows). You can execute this function before making your mod an asset source, but it should be run before resource pack is build. Example use: PolymerModelData modelData = PolymerRPUtils.requestModel(Items.IRON_SWORD, new Identifier(\"mymod\", \"item/silver_sword\")); Requesting armor textures Polymer supports custom armor textures thanks to usage of Ancientkingg's fancyPants resource pack . To request it you need to use PolymerRPUtils.requestArmor(Identifier) . It will automatically create variant of every armor peace, however you aren't required to use/define them all. To apply it to your armor, you need to set your client side item to leather armor peace. Then you need to override PolymerItem.getPolymerArmorColor() method and return used color. PolymerArmorModel armorModel = PolymerRPUtils.requestArmor(new Identifier(\"mymod\", \"silver\")); Checking players Checking if player has resource pack is quite simple. You just need to call boolean PolymerRPUtils.hasPack(ServerPlayerEntity player) . Example use: Identifier font; if (PolymerRPUtils.hasPack(player)) { font = new Identifier(\"mymod\", \"myfont\"); } else { font = new Identifier(\"minecraft\", \"default\"); } Making pack required To make font required, you just need to call ResourcePackUtil.markAsRequired() . However, Polymer doesn't contain any utilities for sending packs, as it should be implemented by other mods (or use vanilla one). One exception is resource pack on client, which will get effected by that. I also recommend you to keep it optional if it's possible. Building resource pack To create resource pack you only need to execute /polymer generate command. Resource pack will be located in your server folder as polymer-resourcepack.zip .","title":"Resource packs"},{"location":"polymer/resource-packs/#resource-packs","text":"While Polymer wasn't originally designed around resource pack, it provides resource pack utilities to make it easier for mods to stay compatible with each other. Currently, it's limited only to item models, as Vanilla only allows these (as of 1.17.1 version).","title":"Resource packs"},{"location":"polymer/resource-packs/#registering-assets","text":"This is quite simple. You just need to do things written below. Ideally it all should run at your mod's initialization.","title":"Registering assets"},{"location":"polymer/resource-packs/#adding-mod-assets-to-resource-pack","text":"First step for adding assets to resource pack is marking mod as asset source. To do it you just need to call boolean PolymerRPUtils.addAssetSource(String modid) , which returns true if modid is valid. This should be called ideally in your mod initializer. Additionally, you can add assets manually by calling PolymerRPBuilder.addData(String path, byte[] data) . You can get instance of it by listening to PolymerRPUtils.RESOURCE_PACK_CREATION_EVENT . Just keep in minds that new one will be created every time resource pack is generated.","title":"Adding mod assets to resource pack"},{"location":"polymer/resource-packs/#requesting-model-for-item","text":"After that you can register your models by calling PolymerModelData PolymerRPUtils.requestModel(Item vanillaItem, Identifier modelPath) . It returns PolymerModelData with contains all information you need for applying custom model data to your items. You need to keep in mind, that modelPath needs to contain main directory (in similar way to vanilla models). While model is created, all it's overrides are copied and applied, so you don't need to request them manually (useful for bows). You can execute this function before making your mod an asset source, but it should be run before resource pack is build. Example use: PolymerModelData modelData = PolymerRPUtils.requestModel(Items.IRON_SWORD, new Identifier(\"mymod\", \"item/silver_sword\"));","title":"Requesting model for item"},{"location":"polymer/resource-packs/#requesting-armor-textures","text":"Polymer supports custom armor textures thanks to usage of Ancientkingg's fancyPants resource pack . To request it you need to use PolymerRPUtils.requestArmor(Identifier) . It will automatically create variant of every armor peace, however you aren't required to use/define them all. To apply it to your armor, you need to set your client side item to leather armor peace. Then you need to override PolymerItem.getPolymerArmorColor() method and return used color. PolymerArmorModel armorModel = PolymerRPUtils.requestArmor(new Identifier(\"mymod\", \"silver\"));","title":"Requesting armor textures"},{"location":"polymer/resource-packs/#checking-players","text":"Checking if player has resource pack is quite simple. You just need to call boolean PolymerRPUtils.hasPack(ServerPlayerEntity player) . Example use: Identifier font; if (PolymerRPUtils.hasPack(player)) { font = new Identifier(\"mymod\", \"myfont\"); } else { font = new Identifier(\"minecraft\", \"default\"); }","title":"Checking players"},{"location":"polymer/resource-packs/#making-pack-required","text":"To make font required, you just need to call ResourcePackUtil.markAsRequired() . However, Polymer doesn't contain any utilities for sending packs, as it should be implemented by other mods (or use vanilla one). One exception is resource pack on client, which will get effected by that. I also recommend you to keep it optional if it's possible.","title":"Making pack required"},{"location":"polymer/resource-packs/#building-resource-pack","text":"To create resource pack you only need to execute /polymer generate command. Resource pack will be located in your server folder as polymer-resourcepack.zip .","title":"Building resource pack"}]}